import{_ as e,c as t,o as a,V as s,aa as r,ab as i}from"./chunks/framework.7Wm2Ym07.js";const k=JSON.parse('{"title":"Graph Widget","description":"","frontmatter":{},"headers":[],"relativePath":"dashboards/graph-widget.md","filePath":"dashboards/graph-widget.md"}'),n={name:"dashboards/graph-widget.md"},o=s('<h1 id="graph-widget" tabindex="-1">Graph Widget <a class="header-anchor" href="#graph-widget" aria-label="Permalink to &quot;Graph Widget&quot;">​</a></h1><p><img src="'+r+'" alt=""><img src="'+i+'" alt=""></p><p>The graph widget encapsulates graph visualization driven by a graph database.</p><h2 id="how-to-use" tabindex="-1">How to use <a class="header-anchor" href="#how-to-use" aria-label="Permalink to &quot;How to use&quot;">​</a></h2><ul><li>add a graph widget to a dashboard</li><li>select the &#39;Graph&#39; option as render option</li><li>select the graph database</li><li>write a (Cypher) query to retrieve the data</li></ul><p>Since a graph needs nodes and edges the query should return them. If the query returns e.g. only numbers or strings the graph widget will not be able to render anything. The typical query will look like this:</p><div class="language-cypher vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cypher</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MATCH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">]</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(m) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span></span></code></pre></div><p>Every node type has a set of properties and by default the rendered label will be the first property. You can select for each node type which property should be used as label.</p><h2 id="centrality-and-analytics" tabindex="-1">Centrality and analytics <a class="header-anchor" href="#centrality-and-analytics" aria-label="Permalink to &quot;Centrality and analytics&quot;">​</a></h2><p>Depending on the underlying graph visualization library you can access various analytics and centrality measures. For example, with yFiles you can access the following:</p><ul><li><strong><a href="https://docs.yworks.com/yfileshtml/#/api/DegreeCentrality" target="_blank" rel="noreferrer">Degree</a></strong>: The degree of a node is the number of edges connected to it. The degree centrality of a node is the number of edges connected to it.</li><li><strong><a href="https://docs.yworks.com/yfileshtml/#/api/ClosenessCentrality" target="_blank" rel="noreferrer">Closeness</a></strong>: The closeness centrality of a node is the average length of the shortest path between the node and all other nodes in the graph.</li><li><strong><a href="https://docs.yworks.com/yfileshtml/#/api/BetweennessCentrality" target="_blank" rel="noreferrer">Betweenness</a></strong>: The betweenness centrality of a node is the number of shortest paths that pass through the</li><li><strong><a href="https://docs.yworks.com/yfileshtml/#/api/EigenvectorCentrality" target="_blank" rel="noreferrer">Eigenvector</a></strong>: The eigenvector centrality of a node is the sum of the centrality scores of its neighbors. This means that a node is important if it is connected to other important nodes.</li><li><strong><a href="https://docs.yworks.com/yfileshtml/#/api/PageRank" target="_blank" rel="noreferrer">PageRank</a></strong>: The PageRank of a node is the probability that a random walk will visit the node. This means that a node is important if it is connected to other important nodes.</li></ul><p>and much more. See the amazing <a href="https://docs.yworks.com/yfileshtml/#/api/Overview" target="_blank" rel="noreferrer">yFiles documentation</a> for more details.</p><p>The (much more) basic <a href="https://js.cytoscape.org/" target="_blank" rel="noreferrer">Cytoscape library</a> also supports various analytics:</p><ul><li><strong><a href="https://js.cytoscape.org/#eles.degreeCentrality" target="_blank" rel="noreferrer">Degree</a></strong>: The degree of a node is the number of edges connected to it. The degree centrality of a node is the number of edges connected to it.</li><li><strong><a href="https://js.cytoscape.org/#eles.closenessCentrality" target="_blank" rel="noreferrer">Closeness</a></strong>: The closeness centrality of a node is the average length of the shortest path between the node and all other nodes in the graph.</li><li><strong><a href="https://js.cytoscape.org/#eles.betweennessCentrality" target="_blank" rel="noreferrer">Betweenness</a></strong>: The betweenness centrality of a node is the number of shortest paths that pass through the</li><li><strong><a href="https://js.cytoscape.org/#eles.pageRank" target="_blank" rel="noreferrer">PageRank</a></strong>: The PageRank of a node is the probability that a random walk will visit the node. This means that a node is important if it is connected to other important nodes.</li></ul><h2 id="layout" tabindex="-1">Layout <a class="header-anchor" href="#layout" aria-label="Permalink to &quot;Layout&quot;">​</a></h2><p>The graph widget supports various layouts. The layout is the way the nodes and edges are arranged on the screen. The set of supported layouts depends on the underlying graph visualization library. The yFiles library boasts a staggering amount of layout algorithms while the Cytoscape package has a limited set.</p>',16),h=[o];function l(d,p,g,c,y,u){return a(),t("div",null,h)}const m=e(n,[["render",l]]);export{k as __pageData,m as default};
