import{_ as e,c as a,o as s,V as t,a6 as i}from"./chunks/framework.Ob-pf6gp.js";const f=JSON.parse('{"title":"Schema Visualization","description":"","frontmatter":{},"headers":[],"relativePath":"clients/nuxt/schemaviz.md","filePath":"clients/nuxt/schemaviz.md"}'),o={name:"clients/nuxt/schemaviz.md"},n=t('<h1 id="schema-visualization" tabindex="-1">Schema Visualization <a class="header-anchor" href="#schema-visualization" aria-label="Permalink to &quot;Schema Visualization&quot;">â€‹</a></h1><p><img src="'+i+'" alt="schema"></p><p>Most graph databases don&#39;t enforce a schema and they infer one on the basis of the data. Only some products like TigerGraph require one to design a schema prior to adding data (as is the case in all relational DB&#39;s).</p><p>If you wish to render a schema it should as simple as calling a DB method (like <code>CALL db.schema()</code> in the case of Neo4j) and turning the returned info into a Qwiery <code>Graph</code> instance.</p><p>If you use the built-in Qwiery data access you can use the <code>inferSchemaGraph</code> method which will also infer the schema. In the case of a SQLite, for instance, this will scan all labels and all edge types and assemble a schema graph correspondingly. This also works with the <code>JsonGraphStore</code> and other implementations.</p><p>Of course, if you don&#39;t have any labels on nodes or edges this will result in an empty schema.</p>',6),c=[n];function r(h,l,d,m,p,u){return s(),a("div",null,c)}const g=e(o,[["render",r]]);export{f as __pageData,g as default};
